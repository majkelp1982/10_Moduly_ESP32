#include "Arduino.h"
#include <WiFi.h>
#include <WiFiUdp.h>
#include "Definition/Pin_definition.h"
#include "ESP_SH1106_OLED/SH1106.h"
#include <OneWire.h>
#include <DallasTemperature.h>
#include "Servo/Servo.h"

struct Device {
	bool fireAlarm=false;
	int tempSet=50;
	int tempOutlet=0;
	int tempInlet=0;
	int tempChimney=0;
	int tempBuffer=0;
	int tempHotWater=0;
	bool pump=false;
	float waterPressure=0;
	int mode=0; //0-CZUWANIE, 1-ROZPALANIE, 2-GRZANIE, 3-GASZENIE
	int throttle=0;
	bool alarm = false;
	bool warning=false;
	bool settings=false;
	bool tempGoHigher = false;		// when true means that water is going warmer, when false means temperature dropping down

};

struct DeviceStr {
	char tempSet[4];
	char tempOutlet[10];
	char tempInlet[4];
	char tempChimney[4];
	char tempBuffer[4];
	char tempHotWater[4];
	char throttle[4];
};

struct Alarm {
	bool present;
	String descriptionLine1;
	String descriptionLine2;
	String descriptionLine3;
};

struct Warning {
	bool present;
	String descriptionLine1;
	String descriptionLine2;
	String descriptionLine3;
};

const int maxAlarmNo = 10;
const int maxWarningNo = 10;

// Function declaration
// Display
void OLEDSetup();
void DisplayValidate();		// In case when display must be refresh this function is called
SH1106 display(true, OLED_RESET, OLED_DC, OLED_CS); 	// FOR SPI

//Driver for whole Fire Place controller
void FirePlaceDriver();

//Alarms and warnings events
void AlarmAndWarningsRegistry();
void AlarmAndWarnings();

// Rotary encoder
void SwitchOn(void);
void KnobRotated(void);

//1 wire function
void TemperatureSensorEvent();

//Push variable's to output
void Outputs();


//Help functions
bool Blink2Hz();
int Sec();
int Sec01();
void MinutesOnFire();
int oled_currentPosTop=100;
int oled_goalPosTop=0;
int oled_currentPosBottom=100;
int oled_goalPosBottom=100;
int oled_pictureNo= 0;

//Device
Device device;
DeviceStr deviceStr;

//One Wire Dallas DS1820
OneWire oneWire(ONE_WIRE_DS);
DallasTemperature sensors(&oneWire);
DeviceAddress tempDeviceAddress;

unsigned int tempGoHigherPreviousMillis;
int tempGoHigherlastTemp=0;
bool tempChanged=false;
int minutesOnFire=0;
int minutesOnFireTemp=0;
bool minutesOnFireAddIsAllow=true;
int mode2StartTemperatur;
bool setTempReach = false;
unsigned int tempTemperaturSensorsEventPreviousMilli;

Alarm fault[maxAlarmNo];
Warning warning[maxWarningNo];

int alarmNoShown=0;
int warningNoShown=0;

//Throttle
Servo servo;

//Rotary encoder
unsigned int switchPreviousMillis=0;
unsigned int knobPreviousMillis=0;

//UDP
IPAddress broadcastIP;
// WiFi variable
WiFiUDP Udp;
unsigned int udpBUSsendMillis = 0;						// for delay purposes
byte data[128];											// store data write/read from UDP
void WiFi_init();
void UDPsendStandardFrame();
void UDPread();

//temporary variables
unsigned int tempLastmillis=0;


void setup()
{
	//Serial
	Serial.begin(921600);
	Serial.println("Start ver.20181007");

    Serial.println("WiFi module initialization.....");
    WiFi_init();											//CAN Module initialization

    //Display setup
	OLEDSetup();

	//Pin setup
	Pin_Setup();

	//Rotary interrupt set
	attachInterrupt(inSW,SwitchOn,FALLING);
	attachInterrupt(inCLK,KnobRotated,FALLING);

	//to register alarm descriptions
	AlarmAndWarningsRegistry();

	//After restart init values
	device.tempSet = 55;
	device.tempHotWater = 0;
	device.tempBuffer = 0;
}

void TEMPFUNKTION()
{
	// TEMP for debugging
	unsigned int currentMillis = millis();
	if ((currentMillis - tempLastmillis) < 500 ) return;
	tempLastmillis = currentMillis;
	// Here code called only one time per second
	Serial.print("Fire="); Serial.print(device.fireAlarm);
	Serial.print(" Set="); Serial.print(device.tempSet);
	Serial.print(" Flow="); Serial.print(device.tempOutlet);
	Serial.print(" Ret="); Serial.print(device.tempInlet);
	Serial.print(" Chimn="); Serial.print(device.tempChimney);
	//Serial.print(" Buf="); Serial.print(device.tempBuffer);
	Serial.print(" Pump="); Serial.print(device.pump);
	//Serial.print(" CWU="); Serial.print(device.tempHotWater);
	//Serial.print(" BAR="); Serial.print(device.waterPressure);
	Serial.print(" mode="); Serial.print(device.mode);
	Serial.print(" throttle="); Serial.print(device.throttle);
	Serial.print(" A="); Serial.print(device.alarm);
	//Serial.print(" W="); Serial.print(device.warning);
	Serial.print(" MinutesOnFire="); Serial.print(minutesOnFire);
	Serial.print(" GOhigher="); Serial.print(device.tempGoHigher);
	Serial.print(" changed="); Serial.print(tempChanged);

	Serial.println();
	Serial.print("INPUT DT:");
	Serial.print(digitalRead(inDT));
	Serial.print(" CLK:");
	Serial.print(digitalRead(inCLK));
	Serial.print(" SW:");
	Serial.println(digitalRead(inSW));
	// TEMP for debugging END
}


void loop()
{
	AlarmAndWarnings();					// This function have to be call before output functions
	DisplayValidate();					// Refresh display
	FirePlaceDriver();
	UDPsendStandardFrame();
	Outputs();

	//TMP
	TEMPFUNKTION();
}

void TempGoHigher()
{
	// this function is called only one time per 30 second
	// if last temperature where lower than present temperature, than TRUE status

	unsigned int currentMillis = millis();
	if ((currentMillis - tempGoHigherPreviousMillis) < 5000 ) return;
	tempGoHigherPreviousMillis = currentMillis;

	if (tempGoHigherlastTemp<device.tempOutlet) device.tempGoHigher=true;
	else device.tempGoHigher = false;

	if (tempGoHigherlastTemp != device.tempOutlet) tempChanged = true;
	else tempChanged = false;

	tempGoHigherlastTemp = device.tempOutlet;
}

void TemperatureSensorEvent()
{
	unsigned int currentMillis = millis();
	if (((currentMillis - tempTemperaturSensorsEventPreviousMilli) < 5000 ) && (device.tempOutlet != 0)) return;
	tempTemperaturSensorsEventPreviousMilli = currentMillis;
	sensors.begin();
	if (sensors.getDeviceCount() != 3) {
		device.tempOutlet = 0;
		device.tempInlet = 0;
		fault[2].present = true;
		switch (sensors.getDeviceCount()) {
		  case 0 : fault[2].descriptionLine2="0"; break;
		  case 1 : fault[2].descriptionLine2="1"; break;
		  case 2 : fault[2].descriptionLine2="2"; break;
		}
		return;
	}

	sensors.requestTemperatures();											// Request temperature and save appropriate
	sensors.getAddress(tempDeviceAddress,0);
	device.tempOutlet = (int)sensors.getTempC(tempDeviceAddress);				// Flow
	sensors.getAddress(tempDeviceAddress,1);
	device.tempInlet = (int)sensors.getTempC(tempDeviceAddress);			// Return
	sensors.getAddress(tempDeviceAddress,2);
	device.tempChimney = (int)sensors.getTempC(tempDeviceAddress);			// Chimney
}

// Functions
void FirePlaceDriver()
{
	if (device.alarm) return;		// return if any alarm active

	//0-CZUWANIE, 1-ROZPALANIE, 2-GRZANIE, 3-GASZENIE
	if (device.mode==0) {
		device.throttle=0;								// Standby shut throttle. Pump is off
		device.pump= false;
		setTempReach = false;
		minutesOnFire = 0;								// Reset minutes on Fire counter
	}

	if (device.mode==1) {
		device.throttle=100;							// By warming up open throttle on 100%
		device.pump = false;							// and shut pump down

		if (device.tempOutlet>50) {						// when reach 50C degree switch to mode 2-GRZANIE
			device.mode=2;
			warning[2].present = true;  				// show warning to shut chimney and manual air-in-take
		}

		//if after 10 minutes flow-temp is not 5 degrees higher than at the begin switch back to standby mode
		if ((minutesOnFire==10) && (device.tempOutlet<(mode2StartTemperatur+5))) device.mode=0;
	}

	if ((device.mode==2) || (device.mode==3)) {
		device.pump=true;
		int delta = device.tempOutlet - device.tempSet;					// delta between Set and Flow temperature
		if (delta<0) device.throttle=100;
		if ((delta>0) && (device.tempGoHigher) && (tempChanged)) {
			device.throttle = (100 - (delta*10));						// set throttle position proportionally to delta
			if (device.throttle<20) device.throttle = 20;
			tempChanged = false;
		}

		if (device.tempOutlet >= device.tempSet) setTempReach = true;		// set if temperature reach set temperature first time
		if ((device.mode==2) && (setTempReach) && 						// warning in mode 2 if fire going down and can't reach set temp. Ask to change to mode 3-exit function
			(device.tempOutlet<(device.tempSet-5)))
			warning[3].present = true;
		if (warning[3].present && (device.tempOutlet>(device.tempSet-5)))	// if warning waren't acknowledge and temperature going up, turn off warning
			warning[3].present = false;

		if (device.tempOutlet<35)	device.mode = 0;						// if temperature is under 35 degree switch to standby
	}

	if ((device.tempOutlet<34) && (device.mode==0)) {
		servo.detach();
		digitalWrite(outSERVO, LOW);
	}

	//Driver functions
	TempGoHigher();
	MinutesOnFire();
	TemperatureSensorEvent();
}

void AlarmAndWarningsRegistry()
{
	//ALARMS

	//when water is over 90 degrees
	fault[0].descriptionLine1="!!!WODA ZAGOTOWANA!!!";
	fault[0].descriptionLine2 = "!!!GASZENIE KOMINKA!!!";

	//when by Standby mode flow-temp is over 40 degrees turn alarm on, that nobody has trigger device to warm up
	fault[1].descriptionLine1 ="TEMPERATURA KOMINKA ";
	fault[1].descriptionLine2 = "W TRYBIE CZUWANIA";
	fault[1].descriptionLine3 = "!!!PRZEKROCZONA!!!";

	//when not all sensors are found
	fault[2].descriptionLine1 ="LICZBA TERMOMETROW :";
	//fault[2].descriptionLine2 = ////////////////// THIS HAVE TO BE REFRESH EVERY TIME AND THEREFORE is in different place
	fault[2].descriptionLine3 = "MA BYC 3";

	//WARNINGS
	//Notice to open chimney and air in-take to max by warming up
	warning[1].descriptionLine1 = "Otworz klape";
	warning[1].descriptionLine2 = "powietrza i komin";
	warning[1].descriptionLine3 = "podczas rozpalania";

	//Notice to shut chimney and air in-take by switching to normal mode
	warning[2].descriptionLine1 = "Zamknij klape";
	warning[2].descriptionLine2 = "powietrza i komin";
	warning[2].descriptionLine3 = "podczas rozpalania";

	//Notice to less timber. Set temperature unable to reach
	warning[3].descriptionLine1 = "Ogien zbyt slaby";
	warning[3].descriptionLine2 = "Zmienic tryb";
	warning[3].descriptionLine3 = "na gaszenie?";
}

void AlarmAndWarnings()
{
	if (device.mode==0) {											//alarm by standby mode
		if (device.tempOutlet>=40) {
			fault[1].present=true;
			minutesOnFire = 0;
		}
	}

	if (device.tempOutlet>90) fault[0].present=true;						//if over heated alarm

	for (int i=0; i<maxAlarmNo; i++)
		if (fault[i].present) device.alarm = true;
	for (int i=0; i<maxWarningNo; i++)
		if (warning[i].present) device.warning = true;

	if (device.alarm) device.throttle = 0;

}

void OLEDSetup()
{
	display.init();
	display.flipScreenVertically();
}

void PrintCenter(int offsetX, int y, String text)
// to reach display center offsetX=64 or by scale 2x offsetX=32
{
	display.drawString(offsetX-display.getStringWidth(text)/2, y,text);
}

void Value2Char()
{
	itoa(device.tempSet,deviceStr.tempSet,10); strcat(deviceStr.tempSet,"C");
	itoa(device.tempOutlet,deviceStr.tempOutlet,10); strcat(deviceStr.tempOutlet,"C("); strcat(deviceStr.tempOutlet,deviceStr.tempSet); strcat(deviceStr.tempOutlet,")");
	itoa(device.tempInlet,deviceStr.tempInlet,10); strcat(deviceStr.tempInlet,"C");
	itoa(device.tempChimney,deviceStr.tempChimney,10); strcat(deviceStr.tempChimney,"C");
	itoa(device.tempHotWater,deviceStr.tempHotWater,10); strcat(deviceStr.tempHotWater,"C");
	itoa(device.tempBuffer,deviceStr.tempBuffer,10); strcat(deviceStr.tempBuffer,"C");
	itoa(device.throttle,deviceStr.throttle,10); strcat(deviceStr.throttle,"%");
}

void DisplayValidate()
{
	Value2Char();
	// Mode ALARM
	if (device.alarm) {
		display.clear();
		display.setTextAlignment(TEXT_ALIGN_LEFT);
		display.setFont(ArialMT_Plain_10);
		if (Blink2Hz()) {
			PrintCenter(64,0,"!!!ALARM!!!");
			display.drawRect(0, 15, 128, 1);
		}
		for (int i=0; i<maxAlarmNo; i++)
			if (fault[i].present) {
				alarmNoShown=i;
				PrintCenter(64,18,fault[i].descriptionLine1);
				PrintCenter(64,29,fault[i].descriptionLine2);
				PrintCenter(64,40,fault[i].descriptionLine3);
			}
		if (Blink2Hz()) {
			PrintCenter(64,51,"OK?");
		}
		display.display();
		return;
	}

	// Mode WARNING
	if (device.warning) {
		display.clear();
		display.setTextAlignment(TEXT_ALIGN_LEFT);
		display.setFont(ArialMT_Plain_10);
		PrintCenter(64,0,"OSTRZEZENIE");
		display.drawRect(0, 15, 128, 1);
		for (int i=0; i<maxWarningNo; i++)
			if (warning[i].present) {
				warningNoShown=i;
				PrintCenter(64,18,warning[i].descriptionLine1);
				PrintCenter(64,29,warning[i].descriptionLine2);
				PrintCenter(64,40,warning[i].descriptionLine3);
			}
		if (Blink2Hz()) PrintCenter(64,51,"OK?");
		display.display();
		return;
	}

	// Mode CZUWANIE. Clear display and stand by
	if (device.mode==0) {
		display.clear();
		display.display();
		return;
	}

	// Mode SETTINGS
	if (device.settings) {
		// Display TOP PART
		display.clear();
		display.setTextAlignment(TEXT_ALIGN_LEFT);
		display.setFont(ArialMT_Plain_10);
		PrintCenter(64,0,"TEMP.ZADANA");
		display.drawRect(0, 15, 128, 1);
		display.setFont(ArialMT_Plain_24);
		PrintCenter(64,20,deviceStr.tempSet);
		display.drawRect(0, 63, 128, 1);
		display.display();
		return;
	}

	//Code to calculate positions animated parts of display
	//Display CENTER PART
	int oled_deltaPosTop, oled_deltaPosBottom;

	if (oled_currentPosTop>0) oled_deltaPosTop = abs(oled_currentPosTop-oled_goalPosTop);					// difference between goal and current position TOP SLOW->FAST
	else oled_deltaPosTop = abs(-100+oled_currentPosTop-oled_goalPosTop);									// difference between goal and current position TOP FAST->SLOW
	if (oled_deltaPosTop<14) oled_deltaPosTop = 14;															// constant scrolling speed when almost goal position TOP

	if (oled_currentPosBottom>0) oled_deltaPosBottom = abs(oled_currentPosBottom-oled_goalPosBottom);		// difference between goal and current position TOP SLOW->FAST
	else oled_deltaPosBottom = abs(-100+oled_currentPosBottom-oled_goalPosBottom);							// difference between goal and current position TOP FAST->SLOW
	if (oled_deltaPosBottom<14) oled_deltaPosBottom = 14;														// constant scrolling speed when almost goal position BOTTOM

	oled_currentPosTop = oled_currentPosTop - (int)oled_deltaPosTop*0.15;									// scroll speed calculation TOP
	if (oled_currentPosTop<oled_goalPosTop) oled_currentPosTop=oled_goalPosTop;								// if current position TOP is too far then POS=GOAL

	oled_currentPosBottom = oled_currentPosBottom - (int)oled_deltaPosBottom*0.15;							// scroll speed calculation BOTTOM
	if (oled_currentPosBottom<oled_goalPosBottom) oled_currentPosBottom=oled_goalPosBottom;					// if current position BOTTOM is too far then POS=GOAL

	if (oled_currentPosTop==0) oled_goalPosBottom=0;														// animation driver
	if (oled_currentPosBottom==0) oled_goalPosTop=-100;
	if (oled_currentPosTop==-100) oled_goalPosBottom=-100;
	if (oled_currentPosBottom==-100) {
		oled_goalPosTop=0;
		oled_currentPosTop=100;
		oled_goalPosBottom=100;
		oled_currentPosBottom=100;
		oled_pictureNo++;
		if (oled_pictureNo>5) oled_pictureNo = 0;
	}

	display.clear();
	display.setTextAlignment(TEXT_ALIGN_LEFT);
	display.setFont(ArialMT_Plain_10);
	switch (device.mode) {
	  case 0 : PrintCenter(64,0,"CZUWANIE"); break;
	  case 1 : PrintCenter(64,0,"ROZPALANIE"); break;
	  case 2 : PrintCenter(64,0,"GRZANIE"); break;
	  case 3 : PrintCenter(64,0,"GASZENIE"); break;
	}

	if (device.pump) {
		if (Blink2Hz()) {
			display.drawRect(0, 6, 20, 1);
			display.drawRect(108, 6, 20, 1);
		};
	};
	display.drawRect(0, 15, 128, 1);

	// Display CENTER PART
	switch (oled_pictureNo) {
	  case 0 : {
		  PrintCenter(64+oled_currentPosTop,18,"ZASILANIE");
		  display.setFont(ArialMT_Plain_24);
		  PrintCenter(64+oled_currentPosBottom,34,deviceStr.tempOutlet);
		  break;
	  }
	  case 1 : {
		  PrintCenter(64+oled_currentPosTop,18,"POWRÓT");
		  display.setFont(ArialMT_Plain_24);
		  PrintCenter(64+oled_currentPosBottom,34,deviceStr.tempInlet);
		  break;
	  }
	  case 2 : {
		  PrintCenter(64+oled_currentPosTop,18,"PRZEPUSTNICA");
		  display.setFont(ArialMT_Plain_24);
		  PrintCenter(64+oled_currentPosBottom,34,deviceStr.throttle);
		  break;
	  }
	  case 3 : {
		  PrintCenter(64+oled_currentPosTop,18,"KOMIN");
		  display.setFont(ArialMT_Plain_24);
		  PrintCenter(64+oled_currentPosBottom,34,deviceStr.tempChimney);
		  break;
	  }
	  case 4 : {
		  PrintCenter(64+oled_currentPosTop,18,"BUFOR");
		  display.setFont(ArialMT_Plain_24);
		  PrintCenter(64+oled_currentPosBottom,34,deviceStr.tempBuffer);
		  break;
	  }
	  case 5 : {
		  PrintCenter(64+oled_currentPosTop,18,"CWU");
		  display.setFont(ArialMT_Plain_24);
		  PrintCenter(64+oled_currentPosBottom,34,deviceStr.tempHotWater);
		  break;
	  }
	}															// IMPORTANT: Switch back to normal mode
	display.drawRect(0, 63, 128, 1);
	display.display();
}

void SwitchOn(void)
{
	unsigned int currentMillis = millis();
	if ((currentMillis - switchPreviousMillis) < 250 ) return;
	switchPreviousMillis = currentMillis;

	if (device.mode==0) {
		device.mode=1;																// if mode CZUWANIE, change to ROZPALANIE and show warning
		warning[1].present = true;
		mode2StartTemperatur = device.tempOutlet;
		servo.attach(outSERVO);														// Servo controller connected to PIN PWM from Arduino
		device.settings = true;

	}

	if ((device.mode==2) && warning[3].present) device.mode=3;						// Change to mode 3-GASZENIE if warning is acknowledge

	if ((!device.alarm) && (!device.warning) && (device.mode>0)) device.settings= !device.settings;


	if ((device.warning) && (warning[3].present)) device.mode = 3;					// when to less fire warning is acknowledge than cool fireplace

	if ((device.warning) && (!device.alarm)) {
		warning[warningNoShown].present=false;
		device.warning = false;
	}
	if (device.alarm) {
		fault[alarmNoShown].present=false;
		device.alarm = false;
	}
}

void KnobRotated(void)
{
	unsigned int currentMillis = millis();
	if ((currentMillis - knobPreviousMillis) < 50 ) return;
	knobPreviousMillis = currentMillis;

	if (digitalRead(inDT) == LOW) {
		if (device.settings) device.tempSet++;
		else {
			oled_pictureNo++;
			//TMP
			device.tempOutlet++;
		}
	}
	else {
		if (device.settings) device.tempSet--;
		else {
			oled_pictureNo--;
			//TMP
			device.tempOutlet--;
		}
	}
	if (oled_pictureNo>5) oled_pictureNo = 0;
	if (oled_pictureNo<0) oled_pictureNo = 5;
	if (device.tempSet<50) device.tempSet = 50;
	if (device.tempSet>90) device.tempSet = 90;
}



void Outputs()
{
	//PUMP
	if (device.pump) digitalWrite(outPUMP,HIGH);
	else digitalWrite(outPUMP,LOW);

	//ALARM
	if ((device.alarm) && (Blink2Hz())) digitalWrite(outSPIKER,HIGH);
	else digitalWrite(outSPIKER,LOW);

	if ((device.warning) && (!device.alarm) && ((Sec()==0) || (Sec()==5)) && (Sec01()==0)) digitalWrite(outSPIKER,HIGH);
	else if (!device.alarm) digitalWrite(outSPIKER,LOW);

	//SERVO
	servo.write(device.throttle+20);
}

int Sec()	// return actual second
{
	unsigned int currentMillis;
	currentMillis = millis();
	return (currentMillis-((currentMillis/10000)*10000))/1000;
}

int Sec01()	// return actual 0,1second
{
	unsigned int currentMillis;
	currentMillis = millis();
	return (currentMillis-((currentMillis/1000)*1000))/100;
}

void MinutesOnFire()
{
	if ((minutesOnFireAddIsAllow) && (Sec()==0)) {
		minutesOnFireTemp++;								// +1 one time per second
		if (minutesOnFireTemp==6) {
			minutesOnFireTemp=0;
			minutesOnFire++;
		}
		minutesOnFireAddIsAllow=false;
	}
	if (Sec() != 0) minutesOnFireAddIsAllow=true;

}

bool Blink2Hz()
{
	if (Sec01()>4) return true;
	else return false;
}

void WiFi_init() {
	// Begin WiFi connection
	WiFi.begin(WIFI_SSID, WIFI_PSWD);
	// Check and wait till connected
    while (!WiFi.isConnected()) {
       Serial.print(".");
       delay(1000);
     }

    // Print details
    Serial.print("Connected : "); Serial.println(WIFI_SSID);
    Serial.print("IP address: ");  Serial.println(WiFi.localIP());

    Udp.begin(LOCAL_PORT);
    Serial.print("Local port: ");

    // broadcast IP
     broadcastIP = WiFi.localIP();
     broadcastIP[3] = 255;
     Serial.print("Broadcast IP: ");
     Serial.println(broadcastIP);
     Serial.println();
}

void UDPsendStandardFrame(void) {
	// return if last telegram were send under 1000ms ago
	unsigned int currentMillis = millis();
	if (currentMillis-udpBUSsendMillis < DELAY_BETWEEN_UDP) return;
	udpBUSsendMillis = millis();

	// First three bytes are reserved for device recognized purposes.
	data[0] = DEVICE_TYP;
	data[1] = DEVICE_NO;
	data[2] = 0;						// Frame 0

	data[3] = (device.mode << 6) | (device.alarm << 5) | (device.warning << 4) | (device.pump << 3) | (device.fireAlarm << 2);
	data[4] = device.throttle;
	data[5] = device.waterPressure*2;
	data[6] = device.tempSet * 2;
	data[7] = device.tempOutlet * 2;
	data[8] = device.tempInlet * 2;
	data[FRAME_SIZE] = device.tempChimney * 2;

	//Send data packet
	Udp.beginPacket(broadcastIP, LOCAL_PORT);
	for (int i=0; i<=FRAME_SIZE; i++) {
		Udp.write(data[i]);

		//TMP
		Serial.print(data[i]);
		Serial.print(" ");

	}
	Udp.endPacket();
}


